
\chapter{Stand der Technik}
\section{Andere Lösungen}
Das Ziel des praktischen Teils der Bachelorarbeit ist es, die Informationen der Statischen Code Analyse übersichtlicher, dauerhafter und benutzerfreundlicher zu präsentieren. Hierbei gibt es ähnliche bereits bestehende Lösungen, deren Probleme im Punkt 2.3.2 Probleme aufgezeigt werden: 

\subsection{Entwicklungsumgebungen}
Bestehende Entwicklungsumgebungen zeigen die Informationen und Warnung bezüglich Fehler und Regelverletzungen zur Übersetzungszeit auf. Dies geschieht in der Zeile bzw. bei der Fehlerquelle, in der sich der Fehler befindet. Die Informationen werden hierbei in einem kleinen Textfeld angezeigt oder gesammelt in einem Ausgabefenster angezeigt  (siehe Abbildung ~\ref{fig:findingsInIDEA}). Weitere Funktionen  sind in einigen Entwicklungsumgebungen extra ergänzt, zum Beispiel die Funktion des automatischen Navigierens von der Übersichtsliste in die Fehlerzeile. Beim Durchführen der Statischen Code Analyse in Entwicklungsumgebungen spricht man von einem \textit{On-Demand-Scan}, da der Entwickler oder die Entwicklerin das Tool für die Analyse manuell startet. Um die Statische Code Analyse in einer Entwicklungsumgebung verwenden zu können, müssen spezifische Tools installiert werden. So bieten Entwicklungsumgebung wie IntelliJ IDEA oder Visual Studio die Möglichkeit Plugins wie SonarLint oder Checkstyle zu installieren. ~\parencite{sonarLint}
\begin{figure}[tp]
  \centering
  \includegraphics[height=7cm]{images/ideChecks.PNG}
  % The short caption should be capitalised
  % The full caption should hold a full sentence. 
 \caption[Anzeige von Fehler in der Entwicklungsumgebung Intellij IDEA]{Anzeige von Fehler in der Entwicklungsumgebung Intellij IDEA.}
  \label{fig:findingsInIDEA}
\end{figure}
\subsection{Build-Server und Continuous Integration (CI)-Pipeline}
Die Statische Code Analyse wird auch bei Build-Server in der CI-Pipeline verwendet. \parencite{zampetti2017open} Der Vorteil dabei ist, dass der Entwickler die Tools nicht lokal installieren muss. Die Tools oder die Plugins werden direkt am Build-Server installiert. Die Code Analyse wird direkt beim automatischen Build durchgeführt. Um diese Option verwenden zu können, gibt es auf Build-Server verfügbare Plugins, wie zum Beispiel das Plugin \textit{Fortify}, dass auf der Build-Server Lösung Jenkins installiert werden kann.
\subsection{SonarQube}
Die Software SonarQube prüft und analysiert das Programm auf bestimmte Faktoren und Regeln. SonarQube fokussiert sich hierbei nicht nur auf die Statische Code Analyse, sondern auch auf dynamische Tests. Die Ergebnisse der Prüfungen und Analyse werden hierbei auf einer Website angezeigt (siehe Abbildung ~\ref{fig:sonarQube}). SonarQube kann sowohl lokal am Rechner, sowie auf einem Build-Server installiert und verwendet werden. Bei einer Installation am Build-Server werden im Zuge des Build-Prozesses auch die SonarQube Prüfungen und Tests durchgeführt. SonarQube unterstützt eine Vielzahl an Programmiersprachen wie Java, C oder C++. Je Projekt können auf der Website die Fehler, Test-Coverage, Duplications und eine weitere Faktoren eingesehen werden. Die Meldungen werden zusätzlich in verschiedene Levels eingeteilt: Blocker (Gewünschte Ausführung der Software kann nicht mehr gewährleistet werden), Critical (Sicherheitslücke oder möglicher Programm-Blocker), Major (Schwerer Qualitätsfehler: Kann die Entwicklung negativ beeinflussen), Minor (Leichter Qualitätsfehler) und Info (Dient nur zur Information). \parencite{sonarQubeHeise}

\begin{figure}[tp]
  \centering
  \includegraphics[height=8cm]{images/sonarQube.PNG}
  % The short caption should be capitalised
  % The full caption should hold a full sentence. 
 \caption[Anzeige von Fehlern und Problemen eines Projekts im SonarQube]{Anzeige von Fehlern und Problemen eines Projekts im SonarQube.}
  \label{fig:sonarQube}
\end{figure}

\subsection{Veracode}
Vercode ist eine Software-Lösung, die den Code auf Security-Lags und anderen Problemen untersucht. Diese Security-Lags Überprüfungen beinhalten unter anderem Open-Source und Third-Party-Tools, fehlerhafte Serverkonfigurationen, Cross-Site Scripting und mangelnde Validierungen. ~\parencite{veracodeSecurity}  Auch wird eine \textit{Software Composition Analysis} durchgeführt. Hierbei werden eingesetzte Open Source Tools auf Sicherheitslücken untersucht. Um eine Veracode-Analyse durchführen zu können, wird der Code auf eine bereitgestellte Website hochgeladen und dort automatisch analysiert und untersucht. Die Ergebnisse sind auf der Website einsehbar. Veracode arbeitet wie SonarQube mit dynamischen und statischen Tests, kann aber auch in Entwicklungsumgebungen eingebunden werden. Ebenso werden eine Vielzahl an Programmiersprachen unterstützt.  ~\parencite{veracodeDig}  

\section{Statische Code Analyse}
Die Code Analyse ist die Analysemöglichkeit des Quellcodes auf Fehler. Dazu ist Statische Code Analyse ist die Analysemöglichkeit des Quellcodes zur Übersetzungszeit. In dieser Analyse werden Prüfungen durchgeführt, die bestimmte Fehler, Regeln und Attribute identifizieren und aufzeigen. ~\parencite{gomes2009overview}
Die Statische Code Analyse soll ein gute Code-Qualität sicherstellen. Für die Beschreibung einer guten Code-Quality gibt es mehrere Modelle, wie das McCall Model, Boehm Model oder das ISO/IEC Proposed Model. ~\parencite{al2011software} Diese Modelle definieren bestimmte Faktoren, die für eine gute Code-Qualität wichtig sind: Portabilität, Interoperabilität, Korrektheit, Zuverlässigkeit, Effizienz, Integrität, Benutzerfreundlichkeit, Testbarkeit, Flexibilität und Wartbarkeit. \parencite{iqbalCodeQualityApproach} Diese Faktoren werden von allen Modellen als bestimmend hervorgehoben, die Modelle unterscheiden sich aber untereinander, wie zum Beispiel bei den Faktoren Dokumentation, Wiederverwendbarkeit und Möglichkeit zur Veränderung des Codes. ~\parencite{boukouchiModels}
Eine gute Code-Qualität kann aber nie durch Tools alleine sichergestellt werden, sondern es erfordert auch manuelle das Testen der Software. 
\subsection{Unterschiede zu dynamischen Tests}
Im Gegensatz zur Statische Code Analyse überprüft die dynamische Code Analyse dynamischen und variablen Aspekte des Programms. Mit verschiedenen Eingabeparametern wird auf ein bestimmtes Ergebnis getestet. \cite{grigorenkoDynTest} Für diese Tests wird eine Simulation erstellt bzw. gestartet. Aus diesem Grund benötigt ein dynamischer Test ein lauffähiges Programm, was bei einem statischen Test nicht vorausgesetzt wird. Ein dynamischer Test auf zwei verschiedene Arten durchgeführt werden: Als Black-Box, White-Box oder diversifizierender Test.
In der Methode des Black-Box-Testings ist das zu testende System der Testerin oder dem Tester nicht bekannt. Hierbei wird ausschließlich die Funktionalität anhand der Spezifikationen getestet. Bei White-Box-Tests ist das System und der Code bekannt, daher sind die ausführenden Tester oft Entwicklerinnen und Entwickler des Programms. Anhand des Programms werden daher Tests erstellt, die bestimmte Teile überprüfen und testen sollen. Bei diversifizierenden Tests hingegen, werden die Testergebnisse nicht mit der Spezifikation verglichen, sondern sie vergleichen verschiedene Versionen der Software. Sind die getesteten Version gleich, so ist der Testfall erfolgreich. Ein diversifizierenden Test kann entweder als Back-to-back-Test (Testen von verschiedene Lösungen und Versionen des Programms), Regressionstest (Wiederholen des selben Tests um sicherzustellen, dass bereits getestete Software-Teile keine neuen Fehler aufweisen) oder als Mutationtest (Leistungsfähigkeit der Testmethoden) durchgeführt werden. \parencite{bommer2016softwarewartung}
\\
Um eine hohe Qualität des Programms zu gewährleisten, müssen daher beide Testverfahren kontinuierlich betrieben werden.
\section{Tools für die Statische Code Analyse}
Für die Statische Code Analyse gibt es eine Vielzahl an Anwendungen und Programmen. Diese Tools können Programmiersprachen-abhängig sein, es gibt aber auch Sprachen übergreifende Lösungen. Die Tools können für allgemeine Code-Smells, aber auch Lösungen für bestimmte Einsatzgebiete sein. Die Entwickler und Entwicklerinnen müssen für  spezifische Probleme und Faktoren bestimmte Tools einsetzten:

\begin{itemize}
\item \textbf{Code-Qualität} beschreibt, ob das Programm seine Funktionen richtig und effizient ausführt. Aber auch Leerzeichen und die Länge von Methoden und Klassen fallen in diese Kategorie. Tools für diese Einsatzbereiche sind CheckStyle oder FindBugs. Aber auch der Faktor der Wiederverwendbarkeit (Hinzufügen von neuen Features, Verwendbarkeit des Codes für andere Entwicklerinnen und Entwickler) fällt in diese Kategorie. Die Tools Jalopy und Crap4j testen den Code auf die Möglichkeit der Wiederverwendbarkeit. Dazu werden Analysen über den Testaufwand und Einhaltung der Coding-Richtlinien erstellt.
\item  \textbf{Code-Smells}
Ein Code-Smell (Bad-Smell) ist kein Compiler-Error oder Programmfehler. Als Code-Smells werden Codeteile bezeichnet, welche überarbeitet werden müssen. Auch das Design-Konzept kann als Bad-Smell bezeichnet werden. Beispiele von Code-Smells sind: Long Method, Temporary Field, Feature Envy, Complex Method und Duplicated Code. Werden Code-Smells nicht überarbeitet, kann es zu Strukturproblemen oder zu Problemen beim Refectoring kommen. Auch die Wiederverwendbarkeit des Codes wird dadurch beeinträchtigt. Code-Smells können durch Tools wie Checkstyle oder PMD identifiziert werden. \cite{palomba2014they}
\item \textbf{Nebenläufigkeit}
beschreibt die Möglichkeit, mehrere Funktionen zur selben Zeit auszuführen. Tools wie Sonar oder CheckThread untersuchen den Code hierbei auf Probleme, wie zum Beispiel Probleme beim Thread-Handling (siehe Race Conditions). Auch doppelter Code, der mit Nebenläufigkeit entfernt werden kann, wird angezeigt.
\item \textbf{Abhängigkeiten}
Beschreibt die Abhängigkeit eines Software-Moduls zu einem anderen Modul. In einer Programm sollten wenige Abhängigkeiten auftreten, da diese bei Ausfall Fehler oder Verzögerungen hervorrufen. Um Abhängigkeitsfehler wie Zirkelbezug vorzubeugen, können Tools wie JDepend oder Dependecy Finder eingesetzt werden. Unter Zirkelbezug versteht man das Auftreten einer Schleife bei Abhängigkeiten.
\item \textbf{Exception-Handling} Mit Exception-Handling können Software-Fehler für weitere Operationen aufgenommen und weitergegeben werden. Hierbei können Fehler wie Deadlocks, redundante Exception-Blocks und Null-Pointer auftreten. Um solche Fehler zu identifizieren können Tools wie JLint eingesetzt werden
\item \textbf{Kompatibilität} Darunter versteht man die Kompatibilität unter verschiedenen Versionen, unter auch zwischen Source- und Binary Code.  Clirr ist ein Tool das die Kompatibilität bei unterschiedlichen Java-Versionen untersucht. 
\item \textbf{Code-Style} Unter Style werden bestimmte Regeln und Coding-Conventions verstanden. Unter anderem gehören dazu Bestimmungen zu Leerzeichen, Klammern und Namenskonventionen. Für die Überprüfung des Code-Styles können Tools wie CheckStyle oder PMD eingesetzt werden.
\item \textbf{Speicherlecks}
Bei einem Speicherleck (memory leak) sind Daten im Arbeitsspeicher gespeichert,  welche aber nicht verwendet oder gelöscht werden. Tools wie Valgrind und Coverity können das Entstehen von Speicherlecks verhindern, indem sie mögliche Fehlerquellen wie Pointer oder Speicherzuweisungen untersuchen.
\item \textbf{Race Conditions}
Bei einer Race Condition greifen zwei verschiedene Services auf eine Ressource oder Methode zu. Da zwei Services nicht gleichzeitig die  gleiche Ressource verwenden können, kann nur eine der beiden Services auf das Ziel zugreifen. Das andere Service kann die Ressource nicht verwenden, was zu einem Fehler oder einem unerwünschten Ergebnis führen kann. Dieses Problem kann bei Threads auftreten. Tools wie JLint oder ConTest können ein Race Condition-Problem feststellen.
\item \textbf{Security}
Security ist ein wichtiger Punkt in Programmen. Tools wie FindBugs, Protecode und Xanitizer analysieren den Code und können Sicherheitsprobleme aufdecken, beispielsweise hard coded Passwörter, (Command) Injection und Response Splitting. \cite{goseva2015capability} Eine hierbei verwendete Technik ist die Taint-Analyse, wo der Datenfluss einer Dateneingaben überprüft wird. \cite{jung2014sensitive}
\end{itemize}

Um die einzelnen Tools bewerten und vergleichen zu können, müssen sie daher in verschiedene Anwendungsbereiche geteilt werden. Bei einer Bewertung der Tools sind aber auch andere Metriken ausschlaggebend wie: Möglichkeit der Erweiterbarkeit der Tools (Open-Source), letztes Release und Art und Vielfalt der Reports. ~\parencite{comparativeAnalysisTools}

\section{Visualisierungen} 
xml report, ide anzeige, 
\subsection{Probleme} 

\subsubsection{Keine dauerhafte Anzeige} 
Der Fokus der Ergebnisanzeige der Statischen Code Analyse in Entwicklungsumgebungen liegt auf das Ausbessern der gefunden Fehler. Die Fehler und Informationen werden daher nach der Ausbesserung nicht mehr angezeigt. Die Entwicklerin oder der Entwickler kann die ausgebesserten Fehler nicht mehr einsehen.

\subsubsection{Keine Verbesserung der Kenntnisse und des Codestils des Entwicklers} 
Da die Fehler nicht dauerhaft angezeigt werden, kommt es zu keiner Verbesserung der Programmierkenntnisse der Entwickler und Entwicklerinnen. Weiters kann in Entwicklungsumgebungen die automatische Ausbesserung getätigt werden, sodass der Entwickler oder die Entwicklerin oft den Fehler nicht bewusst überdenken und selber ausbessern wird. 
Die selben Fehler häufen sich daher immer wieder. Dies geschieht auch, weil besonders unerfahrenere Entwickler einige Fehlerwarnung nicht nachvollziehen und verstehen können, da es keine Möglichkeit gibt die Bugs genauer einsehen zu können. 

\subsubsection{Unübersichtliche Anzeige} 
In großen Klassen, wo sich viele Fehler und Informationen befinden, gehen die einzelnen Fehler in der kleinen Übersichtsanzeige oft unter. In der Zeile, wo sich der Fehler befindet, kann der Fehler nur mit einem Mouseover über die Warnung angezeigt werden. 

\subsubsection{Keine weiteren Analysen}
Weitere Informationen wie Zusammenhänge der Fehler, Analyse der Fehlerquellen, Häufigkeitsverteilungen und zeitliche Veränderungen werden nicht angezeigt. So gehen wichtige Informationen für den Entwickler verloren.